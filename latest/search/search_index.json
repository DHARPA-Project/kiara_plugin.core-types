{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara plugin: core-types \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 Core data types for kiara. Package content \u00b6 data_types \u00b6 boolean : A boolean. integer : An integer. float : A float. date : A date. list : A dictionary. dict : A dictionary. module_types \u00b6 core_types.example : A very simple example module; concatenate two strings. logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. replace : Replace a string if it matches a key in a mapping dictionary. Links \u00b6 Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Home"},{"location":"#kiara-plugin-core-types","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara plugin: core-types"},{"location":"#description","text":"Core data types for kiara.","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#data_types","text":"boolean : A boolean. integer : An integer. float : A float. date : A date. list : A dictionary. dict : A dictionary.","title":"data_types"},{"location":"#module_types","text":"core_types.example : A very simple example module; concatenate two strings. logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. replace : Replace a string if it matches a key in a mapping dictionary.","title":"module_types"},{"location":"#links","text":"Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Package contents API reference","title":"SUMMARY"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"info/SUMMARY/","text":"data_types module_types","title":"SUMMARY"},{"location":"info/data_types/","text":"boolean \u00b6 Documentation A boolean. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name BooleanType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.BooleanType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name bool module_name builtins full_name bool integer \u00b6 Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name IntegerType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.IntegerType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name int module_name builtins full_name int float \u00b6 Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name FloatType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.FloatType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name float module_name builtins full_name float date \u00b6 Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name DateType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.DateType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name datetime module_name datetime full_name datetime.datetime list \u00b6 Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name ListValueType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.ListValueT\u2026 Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name ListModel module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.ListModel dict \u00b6 Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name DictValueType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.DictValueT\u2026 Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name DictModel module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.DictModel","title":"data_types"},{"location":"info/data_types/#kiara_info.data_types.boolean","text":"Documentation A boolean. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name BooleanType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.BooleanType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name bool module_name builtins full_name bool","title":"boolean"},{"location":"info/data_types/#kiara_info.data_types.integer","text":"Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name IntegerType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.IntegerType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name int module_name builtins full_name int","title":"integer"},{"location":"info/data_types/#kiara_info.data_types.float","text":"Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name FloatType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.FloatType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name float module_name builtins full_name float","title":"float"},{"location":"info/data_types/#kiara_info.data_types.date","text":"Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name DateType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.DateType Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name datetime module_name datetime full_name datetime.datetime","title":"date"},{"location":"info/data_types/#kiara_info.data_types.list","text":"Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name ListValueType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.ListValueT\u2026 Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name ListModel module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.ListModel","title":"list"},{"location":"info/data_types/#kiara_info.data_types.dict","text":"Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_plugin\u2026 documentation : https://DHARPA-Project.github.io/kiara_plugin.\u2026 Python class class_name DictValueType module_name kiara_plugin.core_types.data_types full_name kiara_plugin.core_types.data_types.DictValueT\u2026 Config class class_name DataTypeConfig module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class class_name DictModel module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.DictModel","title":"dict"},{"location":"info/module_types/","text":"core_types.example \u00b6 Documentation A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [ KiaraModule ][kiara.modules.KiaraModule]: \u2022 the (optional) configuration class : must inherit from [ KiaraModuleConfig ][kiara.modules.KiaraModuleCo\u2026 and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the [ self.get_config_value(key) ][kiara.modules.Kiar\u2026 method \u2022 the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value \u2022 the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value \u2022 the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Example: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 This example module can be tested on the \u2502 \u2502 commandline with the ``kiara run`` command: \u2502 \u2502 \u2502 \u2502 ``` \u2502 \u2502 kiara run core_types.example text_1=\"xxx\" \u2502 \u2502 text_2=\"yyy\" \u2502 \u2502 ``` \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. separator string The no \" - \" seperator between the two strings. Python class class_name ExampleModule module_name kiara_plugin.core_types.core_types full_name kiara_plugin.core_types.core_types.E\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 separator = self . get_config_value( \"separator\" ) text_1 = inputs . get_value_data( \"text_1\" ) text_2 = inputs . get_value_data( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.not \u00b6 Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name NotModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name AndModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name OrModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.extract_from_string \u00b6 Documentation Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 r\"_(\\d{4}-\\d{2}-\\d{2})_\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name ExtractDateModule module_name kiara_plugin.core_types.core_types.d\u2026 full_name kiara_plugin.core_types.core_types.d\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.check_range \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name DateRangeCheckModule module_name kiara_plugin.core_types.core_types.d\u2026 full_name kiara_plugin.core_types.core_types.d\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 d = inputs . get_value_data( \"date\" ) earliest: Optional[datetime . datetime] = inputs \u2026 latest: Optional[datetime . datetime] = inputs . g\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list.contains \u00b6 Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name IncludedInListCheckModule module_name kiara_plugin.core_types.core_types.l\u2026 full_name kiara_plugin.core_types.core_types.l\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.match_regex \u00b6 Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class class_name RegexModule module_name kiara_plugin.core_types.core_types.s\u2026 full_name kiara_plugin.core_types.core_types.s\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 replace \u00b6 Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class class_name ReplaceStringModule module_name kiara_plugin.core_types.core_types.s\u2026 full_name kiara_plugin.core_types.core_types.s\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"module_types"},{"location":"info/module_types/#kiara_info.module_types.core_types.example","text":"Documentation A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [ KiaraModule ][kiara.modules.KiaraModule]: \u2022 the (optional) configuration class : must inherit from [ KiaraModuleConfig ][kiara.modules.KiaraModuleCo\u2026 and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the [ self.get_config_value(key) ][kiara.modules.Kiar\u2026 method \u2022 the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value \u2022 the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value \u2022 the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Example: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 This example module can be tested on the \u2502 \u2502 commandline with the ``kiara run`` command: \u2502 \u2502 \u2502 \u2502 ``` \u2502 \u2502 kiara run core_types.example text_1=\"xxx\" \u2502 \u2502 text_2=\"yyy\" \u2502 \u2502 ``` \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. separator string The no \" - \" seperator between the two strings. Python class class_name ExampleModule module_name kiara_plugin.core_types.core_types full_name kiara_plugin.core_types.core_types.E\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 separator = self . get_config_value( \"separator\" ) text_1 = inputs . get_value_data( \"text_1\" ) text_2 = inputs . get_value_data( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"core_types.example"},{"location":"info/module_types/#kiara_info.module_types.logic.not","text":"Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name NotModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.not"},{"location":"info/module_types/#kiara_info.module_types.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name AndModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.and"},{"location":"info/module_types/#kiara_info.module_types.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class class_name OrModule module_name kiara_plugin.core_types.core_types.b\u2026 full_name kiara_plugin.core_types.core_types.b\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.or"},{"location":"info/module_types/#kiara_info.module_types.date.extract_from_string","text":"Documentation Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 r\"_(\\d{4}-\\d{2}-\\d{2})_\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name ExtractDateModule module_name kiara_plugin.core_types.core_types.d\u2026 full_name kiara_plugin.core_types.core_types.d\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.extract_from_string"},{"location":"info/module_types/#kiara_info.module_types.date.check_range","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name DateRangeCheckModule module_name kiara_plugin.core_types.core_types.d\u2026 full_name kiara_plugin.core_types.core_types.d\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 d = inputs . get_value_data( \"date\" ) earliest: Optional[datetime . datetime] = inputs \u2026 latest: Optional[datetime . datetime] = inputs . g\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.check_range"},{"location":"info/module_types/#kiara_info.module_types.list.contains","text":"Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class class_name IncludedInListCheckModule module_name kiara_plugin.core_types.core_types.l\u2026 full_name kiara_plugin.core_types.core_types.l\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list.contains"},{"location":"info/module_types/#kiara_info.module_types.string.match_regex","text":"Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class class_name RegexModule module_name kiara_plugin.core_types.core_types.s\u2026 full_name kiara_plugin.core_types.core_types.s\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.match_regex"},{"location":"info/module_types/#kiara_info.module_types.replace","text":"Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class class_name ReplaceStringModule module_name kiara_plugin.core_types.core_types.s\u2026 full_name kiara_plugin.core_types.core_types.s\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"replace"},{"location":"reference/SUMMARY/","text":"kiara_plugin core_types core_types boolean date list string data_types models pipelines","title":"SUMMARY"},{"location":"reference/kiara_plugin/core_types/__init__/","text":"Top-level package for kiara_plugin.core_types. KIARA_METADATA \u00b6 find_data_types : Union [ Type , Tuple , Callable ] \u00b6 find_modules : Union [ Type , Tuple , Callable ] \u00b6 find_pipelines : Union [ Type , Tuple , Callable ] \u00b6 find_value_metadata : Union [ Type , Tuple , Callable ] \u00b6 get_version () \u00b6 Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__ Modules \u00b6 core_types special \u00b6 Classes \u00b6 ExampleModule ( KiaraModule ) \u00b6 A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a KiaraModule : the (optional) configuration class : must inherit from KiaraModuleConfig , and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the self.get_config_value(key) method the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Examples: This example module can be tested on the commandline with the kiara run command: kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" Source code in core_types/core_types/__init__.py class ExampleModule ( KiaraModule ): \"\"\"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [`KiaraModule`][kiara.modules.KiaraModule]: - ***the (optional) configuration class***: must inherit from [`KiaraModuleConfig`][kiara.modules.KiaraModuleConfig], and the config class must be set as the `_config_cls` attribute on the `KiaraModule` class. Configuration values can be retrieved via the [`self.get_config_value(key)`][kiara.modules.KiaraModule.get_config_value] method - ***the inputs description***: must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value - ***the outputs description***: must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value - ***the ``process`` method***: this is where the actual work gets done. Input data can be accessed via ``inputs.get_value_data(key)``, results can be set with the ``outputs.set_value(key, value)`` method Example: This example module can be tested on the commandline with the ``kiara run`` command: ``` kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" ``` \"\"\" _config_cls = ExampleModuleConfig _module_type_name = \"core_types.example\" def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" ) Attributes \u00b6 separator : str pydantic-field \u00b6 The seperator between the two strings. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/__init__.py def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/__init__.py def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/__init__.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result ) ExampleModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" ) Attributes \u00b6 separator : str pydantic-field \u00b6 The seperator between the two strings. Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) data_types \u00b6 This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 BooleanType ( AnyType ) \u00b6 A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) DictValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def calculate_hash ( cls , data : int ) -> str : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> str : return data calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int ListValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) models \u00b6 This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 DictModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 ListModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 pipelines special \u00b6 Default (empty) module that is used as a base path for pipelines contained in this package.","title":"core_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.KIARA_METADATA","text":"","title":"KIARA_METADATA"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_data_types","text":"","title":"find_data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_modules","text":"","title":"find_modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_pipelines","text":"","title":"find_pipelines"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_value_metadata","text":"","title":"find_value_metadata"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.get_version","text":"Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__","title":"get_version()"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types","text":"","title":"core_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule","text":"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a KiaraModule : the (optional) configuration class : must inherit from KiaraModuleConfig , and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the self.get_config_value(key) method the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Examples: This example module can be tested on the commandline with the kiara run command: kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" Source code in core_types/core_types/__init__.py class ExampleModule ( KiaraModule ): \"\"\"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [`KiaraModule`][kiara.modules.KiaraModule]: - ***the (optional) configuration class***: must inherit from [`KiaraModuleConfig`][kiara.modules.KiaraModuleConfig], and the config class must be set as the `_config_cls` attribute on the `KiaraModule` class. Configuration values can be retrieved via the [`self.get_config_value(key)`][kiara.modules.KiaraModule.get_config_value] method - ***the inputs description***: must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value - ***the outputs description***: must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value - ***the ``process`` method***: this is where the actual work gets done. Input data can be accessed via ``inputs.get_value_data(key)``, results can be set with the ``outputs.set_value(key, value)`` method Example: This example module can be tested on the commandline with the ``kiara run`` command: ``` kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" ``` \"\"\" _config_cls = ExampleModuleConfig _module_type_name = \"core_types.example\" def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result )","title":"ExampleModule"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" ) Attributes \u00b6 separator : str pydantic-field \u00b6 The seperator between the two strings.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/__init__.py def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/__init__.py def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/__init__.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModuleConfig","text":"Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" )","title":"ExampleModuleConfig"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModuleConfig-attributes","text":"separator : str pydantic-field \u00b6 The seperator between the two strings.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.boolean-classes","text":"AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.date-classes","text":"DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.list-classes","text":"IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.string-classes","text":"RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package.","title":"data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.BooleanType","text":"A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass","title":"BooleanType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.BooleanType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DictValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 )","title":"DictValueType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DictValueType-methods","text":"calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def calculate_hash ( cls , data : int ) -> str : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> str : return data calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.DictModel","text":"Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash","title":"DictModel"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.DictModel-attributes","text":"data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel","text":"Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel-attributes","text":"data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.pipelines","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"},{"location":"reference/kiara_plugin/core_types/data_types/","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 BooleanType ( AnyType ) \u00b6 A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) DictValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def calculate_hash ( cls , data : int ) -> str : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> str : return data calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int ListValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"data_types"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType","text":"A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass","title":"BooleanType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.validate","text":"Source code in core_types/data_types.py def validate ( cls , value : Any ): pass","title":"validate()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data )) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> str : return str ( hash ( data ))","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.validate","text":"Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"validate()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 )","title":"DictValueType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.render_as__string","text":"Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 )","title":"render_as__string()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.calculate_value_hash","text":"Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> str : return compute_hash ( data )","title":"calculate_value_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def calculate_hash ( cls , data : int ) -> str : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> str : return data","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result ) def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.calculate_size","text":"Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ data = None schema = None if isinstance ( data , Iterable ): schema = { \"title\" : \"list\" , \"type\" : \"object\" } data = data elif isinstance ( data , str ): try : data = orjson . loads ( data ) if not isinstance ( data , str ) and isinstance ( list , Iterable ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : data , \"item_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return ListModel . construct ( ** result )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.render_as__string","text":"Source code in core_types/data_types.py def render_as__string ( self , value : \"Value\" , render_config : Mapping [ str , Any ] ) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"render_as__string()"},{"location":"reference/kiara_plugin/core_types/models/","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 DictModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 ListModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"models"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel","text":"Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash","title":"DictModel"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.data_hash","text":"","title":"data_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.data_schema","text":"The schema.","title":"data_schema"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.dict_data","text":"The data.","title":"dict_data"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.python_class","text":"The python class of which model instances are created. This is mostly meant as a hint for client applications.","title":"python_class"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.schema_hash","text":"","title":"schema_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.size","text":"","title":"size"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.value_hash","text":"","title":"value_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel","text":"Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_hash ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_hash ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_hash ( obj ) return self . _value_hash","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.data_hash","text":"","title":"data_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.item_schema","text":"The schema.","title":"item_schema"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.list_data","text":"The data.","title":"list_data"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.python_class","text":"The python class of which model instances are created. This is mostly meant as a hint for client applications.","title":"python_class"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.schema_hash","text":"","title":"schema_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.size","text":"","title":"size"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.value_hash","text":"","title":"value_hash"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/","text":"Classes \u00b6 ExampleModule ( KiaraModule ) \u00b6 A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a KiaraModule : the (optional) configuration class : must inherit from KiaraModuleConfig , and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the self.get_config_value(key) method the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Examples: This example module can be tested on the commandline with the kiara run command: kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" Source code in core_types/core_types/__init__.py class ExampleModule ( KiaraModule ): \"\"\"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [`KiaraModule`][kiara.modules.KiaraModule]: - ***the (optional) configuration class***: must inherit from [`KiaraModuleConfig`][kiara.modules.KiaraModuleConfig], and the config class must be set as the `_config_cls` attribute on the `KiaraModule` class. Configuration values can be retrieved via the [`self.get_config_value(key)`][kiara.modules.KiaraModule.get_config_value] method - ***the inputs description***: must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value - ***the outputs description***: must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value - ***the ``process`` method***: this is where the actual work gets done. Input data can be accessed via ``inputs.get_value_data(key)``, results can be set with the ``outputs.set_value(key, value)`` method Example: This example module can be tested on the commandline with the ``kiara run`` command: ``` kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" ``` \"\"\" _config_cls = ExampleModuleConfig _module_type_name = \"core_types.example\" def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" ) Attributes \u00b6 separator : str pydantic-field \u00b6 The seperator between the two strings. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/__init__.py def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/__init__.py def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/__init__.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result ) ExampleModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" ) Attributes \u00b6 separator : str pydantic-field \u00b6 The seperator between the two strings. Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"core_types"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule","text":"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a KiaraModule : the (optional) configuration class : must inherit from KiaraModuleConfig , and the config class must be set as the _config_cls attribute on the KiaraModule class. Configuration values can be retrieved via the self.get_config_value(key) method the inputs description : must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value the outputs description : must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value the process method : this is where the actual work gets done. Input data can be accessed via inputs.get_value_data(key) , results can be set with the outputs.set_value(key, value) method Examples: This example module can be tested on the commandline with the kiara run command: kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" Source code in core_types/core_types/__init__.py class ExampleModule ( KiaraModule ): \"\"\"A very simple example module; concatenate two strings. The purpose of this modules is to show the main elements of a [`KiaraModule`][kiara.modules.KiaraModule]: - ***the (optional) configuration class***: must inherit from [`KiaraModuleConfig`][kiara.modules.KiaraModuleConfig], and the config class must be set as the `_config_cls` attribute on the `KiaraModule` class. Configuration values can be retrieved via the [`self.get_config_value(key)`][kiara.modules.KiaraModule.get_config_value] method - ***the inputs description***: must return a dictionary, containing the input name(s) as keys, and another dictionary containing type_name information and documentation about the input data as value - ***the outputs description***: must return a dictionary, containing the output name(s) as keys, and another dictionary containing type_name information and documentation about the output data as value - ***the ``process`` method***: this is where the actual work gets done. Input data can be accessed via ``inputs.get_value_data(key)``, results can be set with the ``outputs.set_value(key, value)`` method Example: This example module can be tested on the commandline with the ``kiara run`` command: ``` kiara run core_types.example text_1=\"xxx\" text_2=\"yyy\" ``` \"\"\" _config_cls = ExampleModuleConfig _module_type_name = \"core_types.example\" def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result )","title":"ExampleModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule._config_cls","text":"Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule._config_cls-attributes","text":"separator : str pydantic-field \u00b6 The seperator between the two strings.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/__init__.py def create_inputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"text_1\" : { \"type\" : \"string\" , \"doc\" : \"The first text.\" }, \"text_2\" : { \"type\" : \"string\" , \"doc\" : \"The second text.\" }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/__init__.py def create_outputs_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The concatenated text.\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModule.process","text":"Source code in core_types/core_types/__init__.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : separator = self . get_config_value ( \"separator\" ) text_1 = inputs . get_value_data ( \"text_1\" ) text_2 = inputs . get_value_data ( \"text_2\" ) result = text_1 + separator + text_2 outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModuleConfig","text":"Source code in core_types/core_types/__init__.py class ExampleModuleConfig ( KiaraModuleConfig ): separator : str = Field ( description = \"The seperator between the two strings.\" , default = \" - \" )","title":"ExampleModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.ExampleModuleConfig.separator","text":"The seperator between the two strings.","title":"separator"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.AndModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule","text":"Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.NotModule","text":"Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.NotModule-methods","text":"create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.OrModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.ExtractDateModule","text":"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.ExtractDateModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModuleConfig","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModuleConfig-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/","text":"Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"boolean"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.process","text":"Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule","text":"Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule._config_cls","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule._config_cls-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule","text":"Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.create_inputs_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.create_outputs_schema","text":"The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.process","text":"Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.process","text":"Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/date/","text":"Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"date"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.process","text":"Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule","text":"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.process","text":"Source code in core_types/core_types/date.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/list/","text":"Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"list"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.process","text":"Source code in core_types/core_types/list.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/string/","text":"Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"string"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule._config_cls","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule._config_cls-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.process","text":"Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule._config_cls","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule._config_cls-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.process","text":"Source code in core_types/core_types/string.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/pipelines/__init__/","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"}]}
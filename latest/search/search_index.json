{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara plugin: core-types \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 Core data types for kiara. Package content \u00b6 data_types \u00b6 integer : An integer. float : A float. date : A date. list : A list. module_types \u00b6 string.filters : -- n/a -- logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary. operations \u00b6 date.check_range : Check whether a date falls within a specified date range. date.extract_from_string : Extract a date object from a string. list.contains : Check whether an element is in a list. logic.and : Returns 'True' if both inputs are 'True'. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'. string_filter.tokens : -- n/a -- Links \u00b6 Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Home"},{"location":"#kiara-plugin-core-types","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara plugin: core-types"},{"location":"#description","text":"Core data types for kiara.","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#data_types","text":"integer : An integer. float : A float. date : A date. list : A list.","title":"data_types"},{"location":"#module_types","text":"string.filters : -- n/a -- logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary.","title":"module_types"},{"location":"#operations","text":"date.check_range : Check whether a date falls within a specified date range. date.extract_from_string : Extract a date object from a string. list.contains : Check whether an element is in a list. logic.and : Returns 'True' if both inputs are 'True'. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'. string_filter.tokens : -- n/a --","title":"operations"},{"location":"#links","text":"Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Package contents API reference","title":"SUMMARY"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"info/SUMMARY/","text":"data_types module_types operations","title":"SUMMARY"},{"location":"info/data_types/","text":"integer \u00b6 lineage integer any qualifier profile(s) -- n/a -- Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name IntegerType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name int python_module_name builtins full_name int float \u00b6 lineage float any qualifier profile(s) -- n/a -- Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name FloatType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name float python_module_name builtins full_name float date \u00b6 lineage date any qualifier profile(s) -- n/a -- Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DateType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name datetime python_module_name datetime full_name datetime.datetime list \u00b6 lineage list any qualifier profile(s) -- n/a -- Documentation A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name ListValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name ListModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026","title":"data_types"},{"location":"info/data_types/#kiara_info.data_types.integer","text":"lineage integer any qualifier profile(s) -- n/a -- Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name IntegerType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name int python_module_name builtins full_name int","title":"integer"},{"location":"info/data_types/#kiara_info.data_types.float","text":"lineage float any qualifier profile(s) -- n/a -- Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name FloatType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name float python_module_name builtins full_name float","title":"float"},{"location":"info/data_types/#kiara_info.data_types.date","text":"lineage date any qualifier profile(s) -- n/a -- Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DateType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name datetime python_module_name datetime full_name datetime.datetime","title":"date"},{"location":"info/data_types/#kiara_info.data_types.list","text":"lineage list any qualifier profile(s) -- n/a -- Documentation A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name ListValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name ListModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026","title":"list"},{"location":"info/module_types/","text":"string.filters \u00b6 Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. filter_n\u2026 string The name yes of the filter. Python class python_class_name StringFiltersModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 filter_name: str = self . get_config_value( \"filt\u2026 data_type_data = self . __class__ . get_supported_\u2026 data_type = data_type_data[ \"type\" ] # data_type_config = data_type_data[\"type_conf\u2026 # TODO: ensure value is of the right type? source_obj = inputs . get_value_obj( \"value\" ) func_name = f\"filter__{ filter_name }\" if not hasattr(self, func_name): raise Exception ( f\"Can't apply filter '{ filter_name }': \u2026 ) func = getattr(self, func_name) # TODO: check signature? filter_inputs = {} for k, v in inputs . items(): if k == data_type: continue filter_inputs[k] = v . data result = func(value = source_obj, filter_inputs = \u2026 if result is None : outputs . set_value( \"value\" , source_obj) else : outputs . set_value( \"value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.not \u00b6 Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name NotModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name AndModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name OrModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.extract_from_string \u00b6 Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name ExtractDateModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text, fuzzy = True ) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.check_range \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name DateRangeCheckModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 d: datetime . datetime = inputs . get_value_data( \"\u2026 earliest: Union[datetime . datetime, None ] = inp\u2026 latest: Union[datetime . datetime, None ] = input\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list.contains \u00b6 Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name IncludedInListCheckModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.match_regex \u00b6 Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class python_class_name RegexModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.replace \u00b6 Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class python_class_name ReplaceStringModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"module_types"},{"location":"info/module_types/#kiara_info.module_types.string.filters","text":"Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. filter_n\u2026 string The name yes of the filter. Python class python_class_name StringFiltersModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 filter_name: str = self . get_config_value( \"filt\u2026 data_type_data = self . __class__ . get_supported_\u2026 data_type = data_type_data[ \"type\" ] # data_type_config = data_type_data[\"type_conf\u2026 # TODO: ensure value is of the right type? source_obj = inputs . get_value_obj( \"value\" ) func_name = f\"filter__{ filter_name }\" if not hasattr(self, func_name): raise Exception ( f\"Can't apply filter '{ filter_name }': \u2026 ) func = getattr(self, func_name) # TODO: check signature? filter_inputs = {} for k, v in inputs . items(): if k == data_type: continue filter_inputs[k] = v . data result = func(value = source_obj, filter_inputs = \u2026 if result is None : outputs . set_value( \"value\" , source_obj) else : outputs . set_value( \"value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.filters"},{"location":"info/module_types/#kiara_info.module_types.logic.not","text":"Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name NotModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.not"},{"location":"info/module_types/#kiara_info.module_types.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name AndModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.and"},{"location":"info/module_types/#kiara_info.module_types.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name OrModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.or"},{"location":"info/module_types/#kiara_info.module_types.date.extract_from_string","text":"Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name ExtractDateModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text, fuzzy = True ) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.extract_from_string"},{"location":"info/module_types/#kiara_info.module_types.date.check_range","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name DateRangeCheckModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 d: datetime . datetime = inputs . get_value_data( \"\u2026 earliest: Union[datetime . datetime, None ] = inp\u2026 latest: Union[datetime . datetime, None ] = input\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.check_range"},{"location":"info/module_types/#kiara_info.module_types.list.contains","text":"Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name IncludedInListCheckModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list.contains"},{"location":"info/module_types/#kiara_info.module_types.string.match_regex","text":"Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class python_class_name RegexModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.match_regex"},{"location":"info/module_types/#kiara_info.module_types.string.replace","text":"Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class python_class_name ReplaceStringModule python_module_name kiara_plugin.core_types.modul\u2026 full_name kiara_plugin.core_types.modul\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.replace"},{"location":"info/operations/","text":"date.check_range \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The yes -- no date defa\u2026 to -- chec\u2026 earli date The no -- no est earl\u2026 defa\u2026 date -- that is allo\u2026 lates date The no -- no t late\u2026 defa\u2026 date -- that is allo\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 within_range boolean A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false') date.extract_from_string \u00b6 Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the (https://github.com/dateutil/dateutil) package to parse strings into dates. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 text stri\u2026 The yes -- no input defa\u2026 stri\u2026 -- Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The date extracted from the input string. list.contains \u00b6 Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether an element is in a list. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list list The yes -- no list. defa\u2026 -- item any The yes -- no elem\u2026 defa\u2026 to -- check for incl\u2026 in the list. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 is_included boolean Whether the element is in the list, or not. logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.nand \u00b6 Documentation Returns 'False' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'False' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.nor \u00b6 Documentation Returns 'True' if both inputs are 'False'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if both inputs are 'False'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.not \u00b6 Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Negates the input. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if one of the inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.xor \u00b6 Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. string_filter.tokens \u00b6 Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation -- n/a -- Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 value stri\u2026 A yes -- no value defa\u2026 of -- type 'str\u2026 filte list A no -- no r_tok list defa\u2026 ens of -- toke\u2026 to filt\u2026 out. repla stri\u2026 The no cemen stri\u2026 t to repl\u2026 the toke\u2026 with. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 value string The filtered value.","title":"operations"},{"location":"info/operations/#kiara_info.operations.date.check_range","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The yes -- no date defa\u2026 to -- chec\u2026 earli date The no -- no est earl\u2026 defa\u2026 date -- that is allo\u2026 lates date The no -- no t late\u2026 defa\u2026 date -- that is allo\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 within_range boolean A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')","title":"date.check_range"},{"location":"info/operations/#kiara_info.operations.date.extract_from_string","text":"Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the (https://github.com/dateutil/dateutil) package to parse strings into dates. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 text stri\u2026 The yes -- no input defa\u2026 stri\u2026 -- Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The date extracted from the input string.","title":"date.extract_from_string"},{"location":"info/operations/#kiara_info.operations.list.contains","text":"Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether an element is in a list. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list list The yes -- no list. defa\u2026 -- item any The yes -- no elem\u2026 defa\u2026 to -- check for incl\u2026 in the list. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 is_included boolean Whether the element is in the list, or not.","title":"list.contains"},{"location":"info/operations/#kiara_info.operations.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.and"},{"location":"info/operations/#kiara_info.operations.logic.nand","text":"Documentation Returns 'False' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'False' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.nand"},{"location":"info/operations/#kiara_info.operations.logic.nor","text":"Documentation Returns 'True' if both inputs are 'False'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if both inputs are 'False'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.nor"},{"location":"info/operations/#kiara_info.operations.logic.not","text":"Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Negates the input. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.not"},{"location":"info/operations/#kiara_info.operations.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if one of the inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.or"},{"location":"info/operations/#kiara_info.operations.logic.xor","text":"Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.xor"},{"location":"info/operations/#kiara_info.operations.string_filter.tokens","text":"Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation -- n/a -- Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 value stri\u2026 A yes -- no value defa\u2026 of -- type 'str\u2026 filte list A no -- no r_tok list defa\u2026 ens of -- toke\u2026 to filt\u2026 out. repla stri\u2026 The no cemen stri\u2026 t to repl\u2026 the toke\u2026 with. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 value string The filtered value.","title":"string_filter.tokens"},{"location":"reference/SUMMARY/","text":"kiara_plugin core_types data_types models modules boolean date list string pipelines","title":"SUMMARY"},{"location":"reference/kiara_plugin/core_types/__init__/","text":"Top-level package for kiara_plugin.core_types. KIARA_METADATA \u00b6 find_data_types : Union [ Type , Tuple , Callable ] \u00b6 find_model_classes : Union [ Type , Tuple , Callable ] \u00b6 find_modules : Union [ Type , Tuple , Callable ] \u00b6 find_pipelines : Union [ Type , Tuple , Callable ] \u00b6 get_version () \u00b6 Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__ Modules \u00b6 data_types \u00b6 This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result ListValueType ( AnyType ) \u00b6 A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) # def render_as__string(self, value: Value, render_config: Mapping[str, Any]) -> str: # # data: ListModel = value.data # return orjson_dumps(data.list_data, option=orjson.OPT_INDENT_2) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result models \u00b6 This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 ListModel ( BaseModel , Sequence , Generic ) pydantic-model \u00b6 A list implentation that contains (optional) schema information of the lists items. Source code in core_types/models.py class ListModel ( BaseModel , Sequence ): \"\"\"A list implentation that contains (optional) schema information of the lists items.\"\"\" class Config : json_loads = orjson . loads json_dumps = orjson_dumps list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash def __getitem__ ( self , item ): return self . list_data . __getitem__ ( item ) def __iter__ ( self ): return self . list_data . __iter__ () def __len__ ( self ): return self . list_data . __len__ () Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 Config \u00b6 Source code in core_types/models.py class Config : json_loads = orjson . loads json_dumps = orjson_dumps json_loads \u00b6 json_dumps ( v , * , default = None , ** args ) \u00b6 Source code in core_types/models.py def orjson_dumps ( v , * , default = None , ** args ): # orjson.dumps returns bytes, to match standard json.dumps we need to decode try : return orjson . dumps ( v , default = default , ** args ) . decode () except Exception as e : if is_debug (): print ( f \"Error dumping json data: { e } \" ) from kiara import dbg dbg ( v ) raise e modules special \u00b6 KIARA_INPUTS_CONFIG \u00b6 log \u00b6 Classes \u00b6 AutoInputsKiaraModule ( KiaraModule ) \u00b6 Base class for kiara modules that want to expose module configuration via user inputs. Source code in core_types/modules/__init__.py class AutoInputsKiaraModule ( KiaraModule ): \"\"\"Base class for kiara modules that want to expose module configuration via user inputs.\"\"\" _config_cls : Type [ KIARA_INPUTS_CONFIG ] = KiaraInputsConfig # type: ignore _is_abstract = True def _create_inputs_schema ( self ) -> None : \"\"\"Assemble the inputs schema and assign it to the approriate instance attributes.\"\"\" try : _input_schemas_data = self . create_inputs_schema () _input_schemas_data = self . config . augment_inputs_schema ( inputs_schema = _input_schemas_data ) if _input_schemas_data is None : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': no inputs schema\" ) if not _input_schemas_data and not self . _allow_empty_inputs : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': empty inputs schema\" ) try : _input_schemas = create_schema_dict ( schema_config = _input_schemas_data ) except Exception as e : raise Exception ( f \"Can't create input schemas for ' { self . alias } ': { e } \" ) defaults = self . _config . defaults constants = self . _config . constants for k , v in defaults . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid default field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) for k , v in constants . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid constant field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) self . _inputs_schema , self . _constants = overlay_constants_and_defaults ( _input_schemas , defaults = defaults , constants = constants ) except Exception as e : raise Exception ( f \"Can't create input schemas for instance ' { self . alias } ': { e } \" ) # type: ignore def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Attributes \u00b6 add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Methods \u00b6 get_data_for_field ( self , field_name , inputs ) \u00b6 Convenience method to quickly access data for a config or input field, depending on the module configuration. Source code in core_types/modules/__init__.py def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name ) KiaraInputsConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Attributes \u00b6 add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) StringFiltersModule ( FilterModule ) \u00b6 Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result create_filter_inputs ( self , filter_name ) \u00b6 Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None filter__tokens ( self , value , filter_inputs ) \u00b6 Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result retrieve_supported_type () classmethod \u00b6 Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" pipelines special \u00b6 Default (empty) module that is used as a base path for pipelines contained in this package.","title":"core_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.KIARA_METADATA","text":"","title":"KIARA_METADATA"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_data_types","text":"","title":"find_data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_model_classes","text":"","title":"find_model_classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_modules","text":"","title":"find_modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_pipelines","text":"","title":"find_pipelines"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.get_version","text":"Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__","title":"get_version()"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package.","title":"data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType-methods","text":"parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType","text":"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) # def render_as__string(self, value: Value, render_config: Mapping[str, Any]) -> str: # # data: ListModel = value.data # return orjson_dumps(data.list_data, option=orjson.OPT_INDENT_2) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel","text":"A list implentation that contains (optional) schema information of the lists items. Source code in core_types/models.py class ListModel ( BaseModel , Sequence ): \"\"\"A list implentation that contains (optional) schema information of the lists items.\"\"\" class Config : json_loads = orjson . loads json_dumps = orjson_dumps list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash def __getitem__ ( self , item ): return self . list_data . __getitem__ ( item ) def __iter__ ( self ): return self . list_data . __iter__ () def __len__ ( self ): return self . list_data . __len__ ()","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel-attributes","text":"data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 Config \u00b6 Source code in core_types/models.py class Config : json_loads = orjson . loads json_dumps = orjson_dumps json_loads \u00b6 json_dumps ( v , * , default = None , ** args ) \u00b6 Source code in core_types/models.py def orjson_dumps ( v , * , default = None , ** args ): # orjson.dumps returns bytes, to match standard json.dumps we need to decode try : return orjson . dumps ( v , default = default , ** args ) . decode () except Exception as e : if is_debug (): print ( f \"Error dumping json data: { e } \" ) from kiara import dbg dbg ( v ) raise e","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules","text":"","title":"modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.KIARA_INPUTS_CONFIG","text":"","title":"KIARA_INPUTS_CONFIG"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.log","text":"","title":"log"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule","text":"Base class for kiara modules that want to expose module configuration via user inputs. Source code in core_types/modules/__init__.py class AutoInputsKiaraModule ( KiaraModule ): \"\"\"Base class for kiara modules that want to expose module configuration via user inputs.\"\"\" _config_cls : Type [ KIARA_INPUTS_CONFIG ] = KiaraInputsConfig # type: ignore _is_abstract = True def _create_inputs_schema ( self ) -> None : \"\"\"Assemble the inputs schema and assign it to the approriate instance attributes.\"\"\" try : _input_schemas_data = self . create_inputs_schema () _input_schemas_data = self . config . augment_inputs_schema ( inputs_schema = _input_schemas_data ) if _input_schemas_data is None : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': no inputs schema\" ) if not _input_schemas_data and not self . _allow_empty_inputs : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': empty inputs schema\" ) try : _input_schemas = create_schema_dict ( schema_config = _input_schemas_data ) except Exception as e : raise Exception ( f \"Can't create input schemas for ' { self . alias } ': { e } \" ) defaults = self . _config . defaults constants = self . _config . constants for k , v in defaults . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid default field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) for k , v in constants . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid constant field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) self . _inputs_schema , self . _constants = overlay_constants_and_defaults ( _input_schemas , defaults = defaults , constants = constants ) except Exception as e : raise Exception ( f \"Can't create input schemas for instance ' { self . alias } ': { e } \" ) # type: ignore def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name )","title":"AutoInputsKiaraModule"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Attributes \u00b6 add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule-methods","text":"get_data_for_field ( self , field_name , inputs ) \u00b6 Convenience method to quickly access data for a config or input field, depending on the module configuration. Source code in core_types/modules/__init__.py def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig","text":"Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"KiaraInputsConfig"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig-attributes","text":"add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.boolean-classes","text":"AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.date-classes","text":"DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.list-classes","text":"IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.modules.string-classes","text":"RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) StringFiltersModule ( FilterModule ) \u00b6 Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result create_filter_inputs ( self , filter_name ) \u00b6 Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None filter__tokens ( self , value , filter_inputs ) \u00b6 Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result retrieve_supported_type () classmethod \u00b6 Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.pipelines","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"},{"location":"reference/kiara_plugin/core_types/data_types/","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result ListValueType ( AnyType ) \u00b6 A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) # def render_as__string(self, value: Value, render_config: Mapping[str, Any]) -> str: # # data: ListModel = value.data # return orjson_dumps(data.list_data, option=orjson.OPT_INDENT_2) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"data_types"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : datetime . datetime ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.validate","text":"Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"validate()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : float ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : int ) -> Union [ None , str , \"SerializedData\" ]: result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType","text":"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A list. Backed by the [kiara_plugin.core_types.models.ListModel] class, this data type allows to (optionally) specify a schema for the items in the list. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) # def render_as__string(self, value: Value, render_config: Mapping[str, Any]) -> str: # # data: ListModel = value.data # return orjson_dumps(data.list_data, option=orjson.OPT_INDENT_2) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/models/","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 ListModel ( BaseModel , Sequence , Generic ) pydantic-model \u00b6 A list implentation that contains (optional) schema information of the lists items. Source code in core_types/models.py class ListModel ( BaseModel , Sequence ): \"\"\"A list implentation that contains (optional) schema information of the lists items.\"\"\" class Config : json_loads = orjson . loads json_dumps = orjson_dumps list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash def __getitem__ ( self , item ): return self . list_data . __getitem__ ( item ) def __iter__ ( self ): return self . list_data . __iter__ () def __len__ ( self ): return self . list_data . __len__ () Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 Config \u00b6 Source code in core_types/models.py class Config : json_loads = orjson . loads json_dumps = orjson_dumps json_loads \u00b6 json_dumps ( v , * , default = None , ** args ) \u00b6 Source code in core_types/models.py def orjson_dumps ( v , * , default = None , ** args ): # orjson.dumps returns bytes, to match standard json.dumps we need to decode try : return orjson . dumps ( v , default = default , ** args ) . decode () except Exception as e : if is_debug (): print ( f \"Error dumping json data: { e } \" ) from kiara import dbg dbg ( v ) raise e","title":"models"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel","text":"A list implentation that contains (optional) schema information of the lists items. Source code in core_types/models.py class ListModel ( BaseModel , Sequence ): \"\"\"A list implentation that contains (optional) schema information of the lists items.\"\"\" class Config : json_loads = orjson . loads json_dumps = orjson_dumps list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash def __getitem__ ( self , item ): return self . list_data . __getitem__ ( item ) def __iter__ ( self ): return self . list_data . __iter__ () def __len__ ( self ): return self . list_data . __len__ ()","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.data_hash","text":"","title":"data_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.item_schema","text":"The schema.","title":"item_schema"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.list_data","text":"The data.","title":"list_data"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.python_class","text":"The python class of which model instances are created. This is mostly meant as a hint for client applications.","title":"python_class"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.schema_hash","text":"","title":"schema_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.size","text":"","title":"size"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.value_hash","text":"","title":"value_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.Config","text":"Source code in core_types/models.py class Config : json_loads = orjson . loads json_dumps = orjson_dumps json_loads \u00b6 json_dumps ( v , * , default = None , ** args ) \u00b6 Source code in core_types/models.py def orjson_dumps ( v , * , default = None , ** args ): # orjson.dumps returns bytes, to match standard json.dumps we need to decode try : return orjson . dumps ( v , default = default , ** args ) . decode () except Exception as e : if is_debug (): print ( f \"Error dumping json data: { e } \" ) from kiara import dbg dbg ( v ) raise e","title":"Config"},{"location":"reference/kiara_plugin/core_types/modules/__init__/","text":"KIARA_INPUTS_CONFIG \u00b6 log \u00b6 Classes \u00b6 AutoInputsKiaraModule ( KiaraModule ) \u00b6 Base class for kiara modules that want to expose module configuration via user inputs. Source code in core_types/modules/__init__.py class AutoInputsKiaraModule ( KiaraModule ): \"\"\"Base class for kiara modules that want to expose module configuration via user inputs.\"\"\" _config_cls : Type [ KIARA_INPUTS_CONFIG ] = KiaraInputsConfig # type: ignore _is_abstract = True def _create_inputs_schema ( self ) -> None : \"\"\"Assemble the inputs schema and assign it to the approriate instance attributes.\"\"\" try : _input_schemas_data = self . create_inputs_schema () _input_schemas_data = self . config . augment_inputs_schema ( inputs_schema = _input_schemas_data ) if _input_schemas_data is None : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': no inputs schema\" ) if not _input_schemas_data and not self . _allow_empty_inputs : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': empty inputs schema\" ) try : _input_schemas = create_schema_dict ( schema_config = _input_schemas_data ) except Exception as e : raise Exception ( f \"Can't create input schemas for ' { self . alias } ': { e } \" ) defaults = self . _config . defaults constants = self . _config . constants for k , v in defaults . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid default field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) for k , v in constants . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid constant field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) self . _inputs_schema , self . _constants = overlay_constants_and_defaults ( _input_schemas , defaults = defaults , constants = constants ) except Exception as e : raise Exception ( f \"Can't create input schemas for instance ' { self . alias } ': { e } \" ) # type: ignore def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Attributes \u00b6 add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Methods \u00b6 get_data_for_field ( self , field_name , inputs ) \u00b6 Convenience method to quickly access data for a config or input field, depending on the module configuration. Source code in core_types/modules/__init__.py def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name ) KiaraInputsConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Attributes \u00b6 add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) StringFiltersModule ( FilterModule ) \u00b6 Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result create_filter_inputs ( self , filter_name ) \u00b6 Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None filter__tokens ( self , value , filter_inputs ) \u00b6 Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result retrieve_supported_type () classmethod \u00b6 Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\"","title":"modules"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KIARA_INPUTS_CONFIG","text":"","title":"KIARA_INPUTS_CONFIG"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.log","text":"","title":"log"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule","text":"Base class for kiara modules that want to expose module configuration via user inputs. Source code in core_types/modules/__init__.py class AutoInputsKiaraModule ( KiaraModule ): \"\"\"Base class for kiara modules that want to expose module configuration via user inputs.\"\"\" _config_cls : Type [ KIARA_INPUTS_CONFIG ] = KiaraInputsConfig # type: ignore _is_abstract = True def _create_inputs_schema ( self ) -> None : \"\"\"Assemble the inputs schema and assign it to the approriate instance attributes.\"\"\" try : _input_schemas_data = self . create_inputs_schema () _input_schemas_data = self . config . augment_inputs_schema ( inputs_schema = _input_schemas_data ) if _input_schemas_data is None : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': no inputs schema\" ) if not _input_schemas_data and not self . _allow_empty_inputs : raise Exception ( f \"Invalid inputs implementation for ' { self . alias } ': empty inputs schema\" ) try : _input_schemas = create_schema_dict ( schema_config = _input_schemas_data ) except Exception as e : raise Exception ( f \"Can't create input schemas for ' { self . alias } ': { e } \" ) defaults = self . _config . defaults constants = self . _config . constants for k , v in defaults . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid default field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) for k , v in constants . items (): if k not in _input_schemas . keys (): raise Exception ( f \"Can't create inputs for ' { self . alias } ', invalid constant field name ' { k } '. Available field names: ' { ', ' . join ( _input_schemas . keys ()) } '\" # type: ignore ) self . _inputs_schema , self . _constants = overlay_constants_and_defaults ( _input_schemas , defaults = defaults , constants = constants ) except Exception as e : raise Exception ( f \"Can't create input schemas for instance ' { self . alias } ': { e } \" ) # type: ignore def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name )","title":"AutoInputsKiaraModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule._config_cls","text":"Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule._config_cls-attributes","text":"add_inputs : bool pydantic-field \u00b6 If set to 'True', parse options will be available as inputs. input_fields : List [ str ] pydantic-field \u00b6 If not empty, only add the fields specified in here to the module inputs schema. augment_inputs_schema ( self , inputs_schema ) \u00b6 Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.AutoInputsKiaraModule.get_data_for_field","text":"Convenience method to quickly access data for a config or input field, depending on the module configuration. Source code in core_types/modules/__init__.py def get_data_for_field ( self , field_name : str , inputs : ValueMap ) -> Any : \"\"\"Convenience method to quickly access data for a config or input field, depending on the module configuration.\"\"\" if not self . config . add_inputs : return self . get_config_value ( field_name ) if self . config . input_fields and field_name not in self . config . input_fields : return self . get_config_value ( field_name ) return inputs . get_value_data ( field_name = field_name )","title":"get_data_for_field()"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig","text":"Base configuration that helps translating module config options into user input schemas. Source code in core_types/modules/__init__.py class KiaraInputsConfig ( KiaraModuleConfig ): \"\"\"Base configuration that helps translating module config options into user input schemas.\"\"\" add_inputs : bool = Field ( description = \"If set to 'True', parse options will be available as inputs.\" , default = True , ) input_fields : List [ str ] = Field ( description = \"If not empty, only add the fields specified in here to the module inputs schema.\" , default_factory = list , ) def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"KiaraInputsConfig"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig.add_inputs","text":"If set to 'True', parse options will be available as inputs.","title":"add_inputs"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig.input_fields","text":"If not empty, only add the fields specified in here to the module inputs schema.","title":"input_fields"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.KiaraInputsConfig.augment_inputs_schema","text":"Source code in core_types/modules/__init__.py def augment_inputs_schema ( self , inputs_schema : Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]] ) -> Mapping [ str , Union [ Mapping [ str , Any ], ValueSchema ]]: if not self . add_inputs : return inputs_schema result : Dict [ str , Any ] = dict ( inputs_schema ) field : ModelField for field_name , field in self . __fields__ . items (): if self . input_fields and field_name not in self . input_fields : continue if field_name in inputs_schema . keys () or field_name in [ \"constants\" , \"defaults\" , \"add_inputs\" , \"input_fields\" , ]: log . debug ( \"ignore.autoadd_input_field\" , field_name = field_name , reason = \"field with that name already exists.\" , ) continue kiara_type : Union [ None , str ] = None if field . shape == SHAPE_LIST : kiara_type = \"list\" elif field . shape == SHAPE_DICT : kiara_type = \"dict\" elif field . type_ == str : kiara_type = \"string\" elif field . type_ == bool : kiara_type = \"boolean\" elif field . type_ == int : kiara_type = \"integer\" elif field . type_ == float : kiara_type = \"float\" elif issubclass ( field . type_ , Mapping ): kiara_type = \"dict\" elif issubclass ( field . type_ , List ): kiara_type = \"list\" if kiara_type is None : raise Exception ( f \"Can't auto-generate inputs schema, type ' { field . type_ } ' for field ' { field_name } ' not supported.\" ) result [ field_name ] = { \"type\" : kiara_type , \"doc\" : field . field_info . description , \"optional\" : not field . required , } if field . default : result [ field_name ][ \"default\" ] = field . default elif field . default_factory : result [ field_name ][ \"default\" ] = field . default_factory () return result","title":"augment_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.AndModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule","text":"Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.LogicProcessingModuleConfig-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.NotModule","text":"Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.NotModule-methods","text":"create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.boolean.OrModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date.DateRangeCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date.ExtractDateModule","text":"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.date.ExtractDateModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.RegexModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.RegexModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.RegexModuleConfig","text":"Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.RegexModuleConfig-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig","text":"Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.ReplaceStringModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.ReplaceStringModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/__init__/#kiara_plugin.core_types.modules.string.StringFiltersModule","text":"Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result create_filter_inputs ( self , filter_name ) \u00b6 Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None filter__tokens ( self , value , filter_inputs ) \u00b6 Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result retrieve_supported_type () classmethod \u00b6 Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\"","title":"StringFiltersModule"},{"location":"reference/kiara_plugin/core_types/modules/boolean/","text":"Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"boolean"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/modules/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.AndModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.AndModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.AndModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.AndModule.process","text":"Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule","text":"Base class for logic-related kiara modules. Source code in core_types/modules/boolean.py class LogicProcessingModule ( KiaraModule ): \"\"\"Base class for logic-related kiara modules.\"\"\" _config_cls = LogicProcessingModuleConfig _is_abstract = True","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule._config_cls","text":"Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModule._config_cls-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/modules/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.NotModule","text":"Negates the input. Source code in core_types/modules/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.NotModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.NotModule.create_inputs_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.NotModule.create_outputs_schema","text":"The output of this module is a single boolean, the negated input. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.NotModule.process","text":"Negates the input boolean. Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/modules/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.OrModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.OrModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/boolean.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.OrModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/boolean.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/boolean/#kiara_plugin.core_types.modules.boolean.OrModule.process","text":"Source code in core_types/modules/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/date/","text":"Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"date"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/modules/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.DateRangeCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.DateRangeCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.DateRangeCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.DateRangeCheckModule.process","text":"Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"earliest\" ) latest : Union [ datetime . datetime , None ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.ExtractDateModule","text":"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the dateutil package to parse strings into dates. Source code in core_types/modules/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is very bare bones so far, only using the standard parser from the [dateutil](https://github.com/dateutil/dateutil) package to parse strings into dates. \"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.ExtractDateModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.ExtractDateModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/date.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.ExtractDateModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/date.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/date/#kiara_plugin.core_types.modules.date.ExtractDateModule.process","text":"Source code in core_types/modules/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text , fuzzy = True ) outputs . set_value ( \"date\" , d_obj )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/list/","text":"Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"list"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/modules/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/list.py def create_inputs_schema ( self , ) -> ValueMapSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/list.py def create_outputs_schema ( self , ) -> ValueMapSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/list/#kiara_plugin.core_types.modules.list.IncludedInListCheckModule.process","text":"Source code in core_types/modules/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/string/","text":"Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) StringFiltersModule ( FilterModule ) \u00b6 Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result create_filter_inputs ( self , filter_name ) \u00b6 Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None filter__tokens ( self , value , filter_inputs ) \u00b6 Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result retrieve_supported_type () classmethod \u00b6 Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\"","title":"string"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/modules/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule._config_cls","text":"Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule._config_cls-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModule.process","text":"Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModuleConfig","text":"Source code in core_types/modules/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig","text":"Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/modules/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule._config_cls","text":"Source code in core_types/modules/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : Union [ str , None ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule._config_cls-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/modules/string.py def create_inputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/modules/string.py def create_outputs_schema ( self , ) -> ValueMapSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.ReplaceStringModule.process","text":"Source code in core_types/modules/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.StringFiltersModule","text":"Source code in core_types/modules/string.py class StringFiltersModule ( FilterModule ): _module_type_name = \"string.filters\" @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\" def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result","title":"StringFiltersModule"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.StringFiltersModule.create_filter_inputs","text":"Source code in core_types/modules/string.py def create_filter_inputs ( self , filter_name : str ) -> Union [ None , ValueMapSchema ]: if filter_name == \"tokens\" : return { \"filter_tokens\" : { \"type\" : \"list\" , \"doc\" : \"A list of tokens to filter out.\" , \"optional\" : True , }, \"replacement\" : { \"type\" : \"string\" , \"doc\" : \"The string to replace the tokens with.\" , \"default\" : \"\" , }, } return None","title":"create_filter_inputs()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.StringFiltersModule.filter__tokens","text":"Source code in core_types/modules/string.py def filter__tokens ( self , value : Value , filter_inputs : Mapping [ str , Any ]): tokens = filter_inputs . get ( \"filter_tokens\" , None ) if not tokens : return None repl = filter_inputs . get ( \"replacement\" ) result : str = value . data for token in tokens : result = result . replace ( token , repl ) # type: ignore return result","title":"filter__tokens()"},{"location":"reference/kiara_plugin/core_types/modules/string/#kiara_plugin.core_types.modules.string.StringFiltersModule.retrieve_supported_type","text":"Source code in core_types/modules/string.py @classmethod def retrieve_supported_type ( cls ) -> Union [ Dict [ str , Any ], str ]: return \"string\"","title":"retrieve_supported_type()"},{"location":"reference/kiara_plugin/core_types/pipelines/__init__/","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"}]}
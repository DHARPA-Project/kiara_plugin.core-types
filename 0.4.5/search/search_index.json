{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara plugin: core-types \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 Core data types for kiara. Package content \u00b6 data_types \u00b6 boolean : A boolean. integer : An integer. float : A float. date : A date. list : A dictionary. dict : A dictionary. module_types \u00b6 logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary. operations \u00b6 date.check_range : Check whether a date falls within a specified date range. date.extract_from_string : Extract a date object from a string. list.contains : Check whether an element is in a list. logic.and : Returns 'True' if both inputs are 'True'. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'. Links \u00b6 Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Home"},{"location":"#kiara-plugin-core-types","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara plugin: core-types"},{"location":"#description","text":"Core data types for kiara.","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#data_types","text":"boolean : A boolean. integer : An integer. float : A float. date : A date. list : A dictionary. dict : A dictionary.","title":"data_types"},{"location":"#module_types","text":"logic.not : Negates the input. logic.and : Returns 'True' if both inputs are 'True'. logic.or : Returns 'True' if one of the inputs is 'True'. date.extract_from_string : Extract a date object from a string. date.check_range : Check whether a date falls within a specified date range. list.contains : Check whether an element is in a list. string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary.","title":"module_types"},{"location":"#operations","text":"date.check_range : Check whether a date falls within a specified date range. date.extract_from_string : Extract a date object from a string. list.contains : Check whether an element is in a list. logic.and : Returns 'True' if both inputs are 'True'. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'.","title":"operations"},{"location":"#links","text":"Documentation: https://DHARPA-Project.github.io/kiara_plugin.core_types Code: https://github.com/DHARPA-Project/kiara_plugin.core_types","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Package contents API reference","title":"SUMMARY"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"info/SUMMARY/","text":"data_types module_types operations","title":"SUMMARY"},{"location":"info/data_types/","text":"boolean \u00b6 lineage boolean any qualifier profile(s) -- n/a -- Documentation A boolean. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name BooleanType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name bool python_module_name builtins full_name bool integer \u00b6 lineage integer any qualifier profile(s) -- n/a -- Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name IntegerType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name int python_module_name builtins full_name int float \u00b6 lineage float any qualifier profile(s) -- n/a -- Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name FloatType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name float python_module_name builtins full_name float date \u00b6 lineage date any qualifier profile(s) -- n/a -- Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DateType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name datetime python_module_name datetime full_name datetime.datetime list \u00b6 lineage list any qualifier profile(s) -- n/a -- Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name ListValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name ListModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026 dict \u00b6 lineage dict any qualifier profile(s) -- n/a -- Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DictValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name DictModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026","title":"data_types"},{"location":"info/data_types/#kiara_info.data_types.boolean","text":"lineage boolean any qualifier profile(s) -- n/a -- Documentation A boolean. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name BooleanType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name bool python_module_name builtins full_name bool","title":"boolean"},{"location":"info/data_types/#kiara_info.data_types.integer","text":"lineage integer any qualifier profile(s) -- n/a -- Documentation An integer. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name IntegerType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name int python_module_name builtins full_name int","title":"integer"},{"location":"info/data_types/#kiara_info.data_types.float","text":"lineage float any qualifier profile(s) -- n/a -- Documentation A float. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name FloatType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name float python_module_name builtins full_name float","title":"float"},{"location":"info/data_types/#kiara_info.data_types.date","text":"lineage date any qualifier profile(s) -- n/a -- Documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DateType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name datetime python_module_name datetime full_name datetime.datetime","title":"date"},{"location":"info/data_types/#kiara_info.data_types.list","text":"lineage list any qualifier profile(s) -- n/a -- Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name ListValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name ListModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026","title":"list"},{"location":"info/data_types/#kiara_info.data_types.dict","text":"lineage dict any qualifier profile(s) -- n/a -- Documentation A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara\u2026 documentation : https://DHARPA-Project.github.io/kiara_\u2026 Python class python_class_name DictValueType python_module_name kiara_plugin.core_types.data_ty\u2026 full_name kiara_plugin.core_types.data_ty\u2026 Config class python_class_name DataTypeConfig python_module_name kiara.data_types full_name kiara.data_types.DataTypeConfig Value class python_class_name DictModel python_module_name kiara_plugin.core_types.models full_name kiara_plugin.core_types.models.\u2026","title":"dict"},{"location":"info/module_types/","text":"logic.not \u00b6 Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name NotModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name AndModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name OrModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.extract_from_string \u00b6 Documentation Extract a date object from a string. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name ExtractDateModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.check_range \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name DateRangeCheckModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 d: datetime . datetime = inputs . get_value_data( \"\u2026 earliest: Optional[datetime . datetime] = inputs \u2026 latest: Optional[datetime . datetime] = inputs . g\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list.contains \u00b6 Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name IncludedInListCheckModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.match_regex \u00b6 Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class python_class_name RegexModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.replace \u00b6 Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class python_class_name ReplaceStringModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"module_types"},{"location":"info/module_types/#kiara_info.module_types.logic.not","text":"Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name NotModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.not"},{"location":"info/module_types/#kiara_info.module_types.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name AndModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.and"},{"location":"info/module_types/#kiara_info.module_types.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. delay number the delay no 0 in seconds from processi\u2026 start to when the output is returned. Python class python_class_name OrModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.or"},{"location":"info/module_types/#kiara_info.module_types.date.extract_from_string","text":"Documentation Extract a date object from a string. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name ExtractDateModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2\u2026 # assert date_match # d_obj = parser.parse(date_match[0]) # type:\u2026 d_obj = parser . parse(text) outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.extract_from_string"},{"location":"info/module_types/#kiara_info.module_types.date.check_range","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name DateRangeCheckModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 d: datetime . datetime = inputs . get_value_data( \"\u2026 earliest: Optional[datetime . datetime] = inputs \u2026 latest: Optional[datetime . datetime] = inputs . g\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if not isinstance(d, datetime . datetime): raise KiaraProcessingException( f\"Invalid f\u2026 if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.check_range"},{"location":"info/module_types/#kiara_info.module_types.list.contains","text":"Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. Python class python_class_name IncludedInListCheckModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list.contains"},{"location":"info/module_types/#kiara_info.module_types.string.match_regex","text":"Documentation Match a string using a regular expression. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constan\u2026 object Value no constants for this module. defaults object Value no defaults for this module. only_fi\u2026 boolean Whether no false to only return the first match, or all matches. regex string The regex yes to apply. Python class python_class_name RegexModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.match_regex"},{"location":"info/module_types/#kiara_info.module_types.string.replace","text":"Documentation Replace a string if it matches a key in a mapping dictionary. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://DHARPA-Project.github.io/kiar\u2026 Module config schema Field Type Descript\u2026 Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. default_\u2026 string The no default value to use if the string to be replaced is not in the replacem\u2026 map. By default, this just returns the string itself. defaults object Value no defaults for this module. replacem\u2026 object A map, yes containi\u2026 the strings to be replaced as keys, and the replacem\u2026 as values. Python class python_class_name ReplaceStringModule python_module_name kiara_plugin.core_types.core_\u2026 full_name kiara_plugin.core_types.core_\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.replace"},{"location":"info/operations/","text":"date.check_range \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The yes -- no date defa\u2026 to -- chec\u2026 earl\u2026 date The no -- no earl\u2026 defa\u2026 date -- that is allo\u2026 late\u2026 date The no -- no late\u2026 defa\u2026 date -- that is allo\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 within_range boolean A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false') date.extract_from_string \u00b6 Documentation Extract a date object from a string. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Extract a date object from a string. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 text stri\u2026 The yes -- no input defa\u2026 stri\u2026 -- Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The date extracted from the input string. list.contains \u00b6 Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether an element is in a list. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list list The yes -- no list. defa\u2026 -- item any The yes -- no elem\u2026 defa\u2026 to -- check for incl\u2026 in the list. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 is_included boolean Whether the element is in the list, or not. logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.nand \u00b6 Documentation Returns 'False' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'False' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.nor \u00b6 Documentation Returns 'True' if both inputs are 'False'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if both inputs are 'False'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.not \u00b6 Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Negates the input. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if one of the inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state. logic.xor \u00b6 Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"operations"},{"location":"info/operations/#kiara_info.operations.date.check_range","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The yes -- no date defa\u2026 to -- chec\u2026 earl\u2026 date The no -- no earl\u2026 defa\u2026 date -- that is allo\u2026 late\u2026 date The no -- no late\u2026 defa\u2026 date -- that is allo\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 within_range boolean A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')","title":"date.check_range"},{"location":"info/operations/#kiara_info.operations.date.extract_from_string","text":"Documentation Extract a date object from a string. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Extract a date object from a string. Inputs field name type desc\u2026 Req\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 text stri\u2026 The yes -- no input defa\u2026 stri\u2026 -- Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date date The date extracted from the input string.","title":"date.extract_from_string"},{"location":"info/operations/#kiara_info.operations.list.contains","text":"Documentation Check whether an element is in a list. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Check whether an element is in a list. Inputs field name type desc\u2026 Requ\u2026 Defa\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list list The yes -- no list. defa\u2026 -- item any The yes -- no elem\u2026 defa\u2026 to -- check for incl\u2026 in the list. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 is_included boolean Whether the element is in the list, or not.","title":"list.contains"},{"location":"info/operations/#kiara_info.operations.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.and"},{"location":"info/operations/#kiara_info.operations.logic.nand","text":"Documentation Returns 'False' if both inputs are 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'False' if both inputs are 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.nand"},{"location":"info/operations/#kiara_info.operations.logic.nor","text":"Documentation Returns 'True' if both inputs are 'False'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if both inputs are 'False'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.nor"},{"location":"info/operations/#kiara_info.operations.logic.not","text":"Documentation Negates the input. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Negates the input. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.not"},{"location":"info/operations/#kiara_info.operations.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Tags core_types Labels package : kiara_plugin.core_types References source_repo : https://github.com/DHARPA-Project/kiara_pl\u2026 documentation : https://DHARPA-Project.github.io/kiara_plu\u2026 Operation details Documentation Returns 'True' if one of the inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.or"},{"location":"info/operations/#kiara_info.operations.logic.xor","text":"Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Author(s) Markus Binsteiner markus@frkl.io Context Labels package : kiara References source_repo : https://github.com/DHARPA-Project/kiara documentation : https://dharpa.org/kiara_documentation/ Operation details Documentation Returns 'True' if exactly one of it's two inputs is 'True'. Inputs field name type desc\u2026 Requ\u2026 Def\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 b bool\u2026 A yes -- bool\u2026 no desc\u2026 def\u2026 this -- input stat\u2026 Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 y boolean A boolean describing the module output state.","title":"logic.xor"},{"location":"reference/SUMMARY/","text":"kiara_plugin core_types core_types boolean date list string data_types models pipelines","title":"SUMMARY"},{"location":"reference/kiara_plugin/core_types/__init__/","text":"Top-level package for kiara_plugin.core_types. KIARA_METADATA \u00b6 find_data_types : Union [ Type , Tuple , Callable ] \u00b6 find_model_classes : Union [ Type , Tuple , Callable ] \u00b6 find_modules : Union [ Type , Tuple , Callable ] \u00b6 find_pipelines : Union [ Type , Tuple , Callable ] \u00b6 get_version () \u00b6 Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__ Modules \u00b6 core_types special \u00b6 Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) data_types \u00b6 This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 BooleanType ( AnyType ) \u00b6 A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) DictValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) Methods \u00b6 calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : int ) -> int : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> int : return data calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result ListValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result models \u00b6 This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 DictModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 ListModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 pipelines special \u00b6 Default (empty) module that is used as a base path for pipelines contained in this package.","title":"core_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.KIARA_METADATA","text":"","title":"KIARA_METADATA"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_data_types","text":"","title":"find_data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_model_classes","text":"","title":"find_model_classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_modules","text":"","title":"find_modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.find_pipelines","text":"","title":"find_pipelines"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.get_version","text":"Source code in core_types/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__","title":"get_version()"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types","text":"","title":"core_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.boolean-classes","text":"AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.date-classes","text":"DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.list-classes","text":"IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.core_types.string-classes","text":"RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package.","title":"data_types"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.BooleanType","text":"A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass","title":"BooleanType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.BooleanType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DateType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DictValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"DictValueType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.DictValueType-methods","text":"calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.FloatType-methods","text":"calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : int ) -> int : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> int : return data calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"Methods"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.DictModel","text":"Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash","title":"DictModel"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.DictModel-attributes","text":"data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel","text":"Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.models.ListModel-attributes","text":"data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/__init__/#kiara_plugin.core_types.pipelines","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"},{"location":"reference/kiara_plugin/core_types/data_types/","text":"This module contains the value type classes that are used in the kiara_plugin.core_types package. Classes \u00b6 BooleanType ( AnyType ) \u00b6 A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24 parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): pass DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result validate ( cls , value ) \u00b6 Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime ) DictValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result FloatType ( AnyType ) \u00b6 A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) Methods \u00b6 calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) calculate_value_hash ( cls , data ) \u00b6 Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result IntegerType ( AnyType ) \u00b6 An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : int ) -> int : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data ) Methods \u00b6 calculate_hash ( cls , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> int : return data calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data ) python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result ListValueType ( AnyType ) \u00b6 A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result Methods \u00b6 calculate_hash ( self , data ) \u00b6 Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash calculate_size ( self , data ) \u00b6 Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size parse_python_obj ( self , data ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model python_class () classmethod \u00b6 Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel render_as__string ( self , value , render_config ) \u00b6 Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) serialize ( self , data ) \u00b6 Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"data_types"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType","text":"A boolean. Source code in core_types/data_types.py class BooleanType ( AnyType [ bool , DataTypeConfig ]): \"A boolean.\" _data_type_name = \"boolean\" @classmethod def python_class ( cls ) -> Type : return bool def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def calculate_size ( self , data : bool ) -> int : return 24 def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0 def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" ) def validate ( cls , value : Any ): pass","title":"BooleanType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : bool ) -> int : return 1 if data else 0","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : bool ) -> int : return 24","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description bool 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> bool : if data is True or data is False : return data elif data == 0 : return False elif data == 1 : return True elif isinstance ( data , str ): if data . lower () == \"true\" : return True elif data . lower () == \"false\" : return False raise Exception ( f \"Can't parse value ' { data } ' as boolean.\" )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return bool","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.BooleanType.validate","text":"Source code in core_types/data_types.py def validate ( cls , value : Any ): pass","title":"validate()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core_types/data_types.py class DateType ( AnyType [ datetime . datetime , DataTypeConfig ]): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _data_type_name = \"date\" @classmethod def python_class ( cls ) -> Type : return datetime . datetime def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data ) def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" ) def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"DateType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : datetime . datetime ) -> int : return compute_cid ( data )","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : datetime . datetime ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description datetime 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> datetime . datetime : from dateutil import parser if isinstance ( data , str ): d = parser . parse ( data ) return d elif isinstance ( data , datetime . date ): _d = datetime . datetime ( year = data . year , month = data . month , day = data . day ) return _d raise Exception ( f \"Can't parse data into a 'datetime' object: { data } \" )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return datetime . datetime","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DateType.validate","text":"Source code in core_types/data_types.py def validate ( cls , value : Any ): assert isinstance ( value , datetime . datetime )","title":"validate()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class DictValueType ( AnyType [ DictModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"dict\" @classmethod def python_class ( cls ) -> Type : return DictModel def calculate_size ( self , data : DictModel ) -> int : return data . size def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result ) def _validate ( self , data : DictModel ) -> None : if not isinstance ( data , DictModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"DictValueType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : DictModel ) -> int : return data . value_hash","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : DictModel ) -> int : return data . size","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description DictModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> DictModel : python_cls = data . __class__ dict_data = None schema = None if isinstance ( data , Mapping ): schema = { \"title\" : \"dict\" , \"type\" : \"object\" } dict_data = data elif isinstance ( data , BaseModel ): dict_data = data . dict () schema = data . schema () elif isinstance ( data , str ): try : dict_data = orjson . loads ( data ) schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : pass if dict_data is None or schema is None : raise Exception ( f \"Invalid data for value type 'dict': { data } \" ) result = { \"data\" : dict_data , \"data_schema\" : schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } return DictModel . construct ( ** result )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return DictModel","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.render_as__string","text":"Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : DictModel = value . data return orjson_dumps ( data . dict_data , option = orjson . OPT_INDENT_2 )","title":"render_as__string()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.DictValueType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : DictModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType","text":"A float. Source code in core_types/data_types.py class FloatType ( AnyType [ float , DataTypeConfig ]): \"A float.\" _data_type_name = \"float\" @classmethod def python_class ( cls ) -> Type : return float def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data ) def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def _validate ( cls , value : Any ) -> Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"FloatType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.calculate_value_hash","text":"Source code in core_types/data_types.py def calculate_value_hash ( cls , data : float ) -> int : return compute_cid ( data )","title":"calculate_value_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return float","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.FloatType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType","text":"An integer. Source code in core_types/data_types.py class IntegerType ( AnyType [ int , DataTypeConfig ]): \"\"\"An integer.\"\"\" _data_type_name = \"integer\" @classmethod def python_class ( cls ) -> Type : return int def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result def calculate_hash ( cls , data : int ) -> int : return data def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data ) def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return SCALAR_CHARACTERISTICS def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"IntegerType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( cls , data : int ) -> int : return data","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : int ) -> int : return sys . getsizeof ( data )","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description int 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> int : return int ( data )","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return int","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.IntegerType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : bool ) -> SerializedData : result = self . serialize_as_json ( data ) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType","text":"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. Source code in core_types/data_types.py class ListValueType ( AnyType [ ListModel , DataTypeConfig ]): \"\"\"A dictionary. In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. \"\"\" _data_type_name = \"list\" @classmethod def python_class ( cls ) -> Type : return ListModel def calculate_size ( self , data : ListModel ) -> int : return data . size def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash def _retrieve_characteristics ( self ) -> DataTypeCharacteristics : return DataTypeCharacteristics ( is_scalar = False , is_json_serializable = True ) def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model def _validate ( self , data : ListModel ) -> None : if not isinstance ( data , ListModel ): raise Exception ( f \"Invalid type: { type ( data ) } .\" ) def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 ) def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"ListValueType"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.calculate_hash","text":"Calculate the hash of the value. Source code in core_types/data_types.py def calculate_hash ( self , data : ListModel ) -> int : return data . value_hash","title":"calculate_hash()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.calculate_size","text":"Calculate the size of the value. Source code in core_types/data_types.py def calculate_size ( self , data : ListModel ) -> int : return data . size","title":"calculate_size()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.parse_python_obj","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description ListModel 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core_types/data_types.py def parse_python_obj ( self , data : Any ) -> ListModel : python_cls = data . __class__ _data = None _schema = None if isinstance ( data , Mapping ) and \"list_data\" in data . keys (): list_model = ListModel ( ** data ) return list_model if isinstance ( data , Iterable ): _schema = { \"title\" : \"list\" , \"type\" : \"object\" } _data = data elif isinstance ( data , str ): try : _data = orjson . loads ( data ) if not isinstance ( _data , str ) and isinstance ( list , Iterable ): _schema = { \"title\" : \"dict\" , \"type\" : \"object\" } except Exception : if isinstance ( _data , str ): raise Exception ( \"Can't create list: can't parse string as json into list.\" ) if _data is None or _schema is None : raise Exception ( f \"Invalid data for value type 'list': { data } \" ) result = { \"list_data\" : _data , \"item_schema\" : _schema , \"python_class\" : PythonClass . from_class ( python_cls ) . dict (), } result_model = ListModel ( ** result ) return result_model","title":"parse_python_obj()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.python_class","text":"Source code in core_types/data_types.py @classmethod def python_class ( cls ) -> Type : return ListModel","title":"python_class()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.render_as__string","text":"Source code in core_types/data_types.py def render_as__string ( self , value : Value , render_config : Mapping [ str , Any ]) -> str : data : ListModel = value . data return orjson_dumps ( data . list_data , option = orjson . OPT_INDENT_2 )","title":"render_as__string()"},{"location":"reference/kiara_plugin/core_types/data_types/#kiara_plugin.core_types.data_types.ListValueType.serialize","text":"Source code in core_types/data_types.py def serialize ( self , data : ListModel ) -> SerializedData : result = self . serialize_as_json ( data . dict ()) return result","title":"serialize()"},{"location":"reference/kiara_plugin/core_types/models/","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.core_types package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. Classes \u00b6 DictModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 data_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. dict_data : Dict [ str , Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6 ListModel ( BaseModel ) pydantic-model \u00b6 Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash Attributes \u00b6 data_hash : int property readonly \u00b6 item_schema : Dict [ str , Any ] pydantic-field required \u00b6 The schema. list_data : List [ Any ] pydantic-field required \u00b6 The data. python_class : PythonClass pydantic-field required \u00b6 The python class of which model instances are created. This is mostly meant as a hint for client applications. schema_hash : int property readonly \u00b6 size property readonly \u00b6 value_hash : int property readonly \u00b6","title":"models"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel","text":"Source code in core_types/models.py class DictModel ( BaseModel ): dict_data : Dict [ str , Any ] = Field ( description = \"The data.\" ) data_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . dict_data ) + len ( self . data_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . dict_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . data_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"data_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash","title":"DictModel"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.data_hash","text":"","title":"data_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.data_schema","text":"The schema.","title":"data_schema"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.dict_data","text":"The data.","title":"dict_data"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.python_class","text":"The python class of which model instances are created. This is mostly meant as a hint for client applications.","title":"python_class"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.schema_hash","text":"","title":"schema_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.size","text":"","title":"size"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.DictModel.value_hash","text":"","title":"value_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel","text":"Source code in core_types/models.py class ListModel ( BaseModel ): list_data : List [ Any ] = Field ( description = \"The data.\" ) item_schema : Dict [ str , Any ] = Field ( description = \"The schema.\" ) python_class : PythonClass = Field ( description = \"The python class of which model instances are created. This is mostly meant as a hint for client applications.\" ) _size_cache : int = PrivateAttr ( default = None ) _hash_cache : int = PrivateAttr ( default = None ) _data_hash : int = PrivateAttr ( default = None ) _schema_hash : int = PrivateAttr ( default = None ) _value_hash : int = PrivateAttr ( default = None ) @property def size ( self ): if self . _size_cache is not None : return self . _size_cache self . _size_cache = len ( self . list_data ) + len ( self . item_schema ) return self . _size_cache @property def data_hash ( self ) -> int : if self . _data_hash is not None : return self . _data_hash self . _data_hash = compute_cid ( self . list_data ) return self . _data_hash @property def schema_hash ( self ) -> int : if self . _schema_hash is not None : return self . _schema_hash self . _schema_hash = compute_cid ( self . item_schema ) return self . _schema_hash @property def value_hash ( self ) -> int : if self . _value_hash is not None : return self . _value_hash obj = { \"data\" : self . data_hash , \"item_schema\" : self . schema_hash } self . _value_hash = compute_cid ( obj ) return self . _value_hash","title":"ListModel"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.data_hash","text":"","title":"data_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.item_schema","text":"The schema.","title":"item_schema"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.list_data","text":"The data.","title":"list_data"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.python_class","text":"The python class of which model instances are created. This is mostly meant as a hint for client applications.","title":"python_class"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.schema_hash","text":"","title":"schema_hash"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.size","text":"","title":"size"},{"location":"reference/kiara_plugin/core_types/models/#kiara_plugin.core_types.models.ListModel.value_hash","text":"","title":"value_hash"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/","text":"Modules \u00b6 boolean \u00b6 Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) date \u00b6 Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) list \u00b6 Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) string \u00b6 Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"core_types"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean","text":"","title":"boolean"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.AndModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule","text":"Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.NotModule","text":"Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.NotModule-methods","text":"create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.boolean.OrModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date","text":"","title":"date"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.ExtractDateModule","text":"Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.date.ExtractDateModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list","text":"","title":"list"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string","text":"","title":"string"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModuleConfig","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.RegexModuleConfig-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/__init__/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/","text":"Classes \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModule ( KiaraModule ) \u00b6 Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. LogicProcessingModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) Attributes \u00b6 delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_outputs_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"boolean"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core_types/core_types/boolean.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" _module_type_name = \"logic.and\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.AndModule.process","text":"Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule","text":"Source code in core_types/core_types/boolean.py class LogicProcessingModule ( KiaraModule ): _config_cls = LogicProcessingModuleConfig","title":"LogicProcessingModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule._config_cls","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModule._config_cls-attributes","text":"delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core_types/core_types/boolean.py class LogicProcessingModuleConfig ( KiaraModuleConfig ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" # this is used to simulate longer running jobs delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule","text":"Negates the input. Source code in core_types/core_types/boolean.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" _module_type_name = \"logic.not\" def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.create_inputs_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.create_outputs_schema","text":"The output of this module is a single boolean, the negated input. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.NotModule.process","text":"Negates the input boolean. Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core_types/core_types/boolean.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" _module_type_name = \"logic.or\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/boolean.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/boolean.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/boolean/#kiara_plugin.core_types.core_types.boolean.OrModule.process","text":"Source code in core_types/core_types/boolean.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/date/","text":"Classes \u00b6 DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches ) ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"date"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core_types/core_types/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"date.check_range\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs : Dict [ str , Dict [ str , Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.DateRangeCheckModule.process","text":"Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : d : datetime . datetime = inputs . get_value_data ( \"date\" ) earliest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if not isinstance ( d , datetime . datetime ): raise KiaraProcessingException ( f \"Invalid format for input date: { type ( d ) } \" ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest # type: ignore outputs . set_value ( \"within_range\" , matches )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule","text":"Extract a date object from a string. Source code in core_types/core_types/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string.\"\"\" _module_type_name = \"date.extract_from_string\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/date.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/date.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/date/#kiara_plugin.core_types.core_types.date.ExtractDateModule.process","text":"Source code in core_types/core_types/date.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) # date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", text) # assert date_match # d_obj = parser.parse(date_match[0]) # type: ignore d_obj = parser . parse ( text ) outputs . set_value ( \"date\" , d_obj )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/list/","text":"Classes \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"list"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core_types/core_types/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"list.contains\" def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/list.py def create_inputs_schema ( self , ) -> ValueSetSchema : inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/list.py def create_outputs_schema ( self , ) -> ValueSetSchema : outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/list/#kiara_plugin.core_types.core_types.list.IncludedInListCheckModule.process","text":"Source code in core_types/core_types/list.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/string/","text":"Classes \u00b6 RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) Attributes \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) Attributes \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"string"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule","text":"Match a string using a regular expression. Source code in core_types/core_types/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"string.match_regex\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule._config_cls","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule._config_cls-attributes","text":"only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModule.process","text":"Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig","text":"Source code in core_types/core_types/string.py class RegexModuleConfig ( KiaraModuleConfig ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core_types/core_types/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"string.replace\" def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule._config_cls","text":"Source code in core_types/core_types/string.py class ReplaceModuleConfig ( KiaraModuleConfig ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"_config_cls"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule._config_cls-attributes","text":"default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values.","title":"Attributes"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in core_types/core_types/string.py def create_inputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in core_types/core_types/string.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/core_types/core_types/string/#kiara_plugin.core_types.core_types.string.ReplaceStringModule.process","text":"Source code in core_types/core_types/string.py def process ( self , inputs : ValueMap , outputs : ValueMap ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"reference/kiara_plugin/core_types/pipelines/__init__/","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"}]}